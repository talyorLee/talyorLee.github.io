索引结构

## redo log / bin log

### redo log 的概念是什么? 为什么会存在.

redo log 是重做日志。主要用于 MySQL 异常重启后的一种数据恢复手段，确保了数据的一致性。
归根到底是 MySQL 为了实现 WAL 机制的一种手段。
因为 MySQL 进行更新操作，为了能够快速响应，所以采用了异步写回磁盘的技术，写入内存后就返回。
但是会存在 crash 后内存数据丢失的隐患，而 redo log 具备 crash safe 能力。

### 什么是 WAL(write-ahead log)机制, 好处是什么.

    WAL机制是写前日志，也就是MySQL更新操作后在真正把数据写入到磁盘前先记录日志。
    好处是不用每一次操作都实时把数据写盘，就算crash后也可以通过redo log重放恢复，所以能够实现快速响应SQL语句。

### redo log 为什么可以保证 crash safe 机制.

### binlog 的概念是什么, 起到什么作用, 可以做 crash safe 吗?

### binlog 和 redolog 的不同点有哪些?

### 物理一致性和逻辑一直性各应该怎么理解?

### 执行器和 innoDB 在执行 update 语句时候的流程是什么样的?

### 如果数据库误操作, 如何执行数据恢复?

### 什么是两阶段提交, 为什么需要两阶段提交, 两阶段提交怎么保证数据库中两份日志间的逻辑一致性(什么叫逻辑一致性)?

### 如果不是两阶段提交, 先写 redo log 和先写 bin log 两种情况各会遇到什么问题?

## 索引

### 索引的作用：提高数据查询效率

### 常见索引模型：哈希表、有序数组、搜索树

### 哈希表：键 - 值(key - value)。

### 哈希思路：把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置

### 哈希冲突的处理办法：链表

### 哈希表适用场景：只有等值查询的场景

### 有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))

### 有序数组查询效率高，更新效率低

### 有序数组的适用场景：静态存储引擎。

### 二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子

### 二叉搜索树：查询时间复杂度 O(log(N))，更新时间复杂度 O(log(N))

### 数据库存储大多不适用二叉树，因为树高过高，会适用 N 叉树

### InnoDB 中的索引模型：B+Tree

### 索引类型：主键索引、非主键索引

主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)

### 主键索引和普通索引的区别：主键索引只要搜索 ID 这个 B+Tree 即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)

### 一个数据页满了，按照 B+Tree 算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概 50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。

### 从性能和存储空间方面考量，自增主键往往是更合理的选择。

### 没有主键的表，有一个普通索引。怎么回表？

    没有主键的表，innodb会给默认创建一个Rowid做主键

### innodb B+树主键索引的叶子节点存的是什么

    B+树的叶子节点是page （页），一个页里面可以存多个行

3. 索引的实现由存储引擎来决定，InnoDB 使用 B+树（N 叉树，比如 1200 叉树），把整颗树的高度维持在很小的范围内，同时在内存里缓存前面若干层的节点，可以极大地降低访问磁盘的次数，提高读的效率。
4. B+树的插入可能会引起数据页的分裂，删除可能会引起数据页的合并，二者都是比较重的 IO 消耗，所以比较好的方式是顺序插入数据，这也是我们一般使用自增主键的原因之一。

1.select _ from T where k in(1,2,3,4,5)
2.select _ from T where k between 1 and 5
第一个要树搜素 5 次
第二个搜索一次
1.in 内部的数字是未知的，不知道是否有序，是否连续等，所以你只能一个一个去看。2.一个已知的升序、范围查询，只需定位第一个值，后面遍历就行了。

思考题：
如果删除，新建主键索引，会同时去修改普通索引对应的主键索引，性能消耗比较大。
删除重建普通索引貌似影响不大，不过要注意在业务低谷期操作，避免影响业务

直接删掉主键索引是不好的，它会使得所有的二级索引都失效，并且会用 ROWID 来作主键索引；

## join

    inner join
    left join
    right join

    如果join的列没有索引
    simple nested-loop join: m*n
        block nested-loop join : m*n 表一加载进		join_beffer内存,进行条件判断
            有索引
                index nested-loop join : m*log2n

## join 优化

    simple nested-loop join/index nested-loop join：
        BKA算法 将id加载进join buffer ，对id排序，磁盘顺序读的概率更高

## sql 优化

https://zhuanlan.zhihu.com/p/58269930
会放弃索引的操作
is null
!= < >
or
in
左边使用表达式操作/函数操作
like
联合索引

## next key lock

https://www.cnblogs.com/zhoujinyi/p/3435982.html

    主键索引有此数据 record lock

    主键索引但无此数据 gap lock

    非主键索引 gap lock  此gap + 下一个gap

    非主键索引且表中无主键 gap lock 此gap + 下一个gap

## mysql 主从同步过程
